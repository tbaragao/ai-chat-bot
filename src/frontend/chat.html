<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Chatbot Demo</title>
    <!-- Tailwind (Play CDN) for utility classes used below -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and ReactDOM from CDN -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      body {
        margin: 0;
        font-family: system-ui, sans-serif;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useRef, useMemo } = React;

      function clsx(...parts) {
        return parts.filter(Boolean).join(" ");
      }

      function escapeHtml(unsafe) {
        return String(unsafe)
          .replaceAll(/&/g, "&amp;")
          .replaceAll(/</g, "&lt;")
          .replaceAll(/>/g, "&gt;")
          .replaceAll(/\"/g, "&quot;")
          .replaceAll(/'/g, "&#039;");
      }

      // Very simple markdown link support: [text](url) or [text] (url)
      function renderMarkdownLinks(escapedText) {
        const mdLink = /\[([^\]]+)\]\s*\((https?:\/\/[^\s)]+)\)/g;
        return escapedText.replace(mdLink, (m, text, href) => {
          const safeHref = href.replaceAll('"', '%22');
          return `<a href="${safeHref}" target="_blank" rel="noopener noreferrer" class="text-blue-700 underline">${text}</a>`;
        });
      }

      function renderMessageHtml(msg) {
        const raw = getTextFromMessage(msg);
        const escaped = escapeHtml(raw);
        return renderMarkdownLinks(escaped);
      }

      function getTextFromMessage(msg) {
        if (!msg) return "";
        const blocks = Array.isArray(msg.contents)
          ? msg.contents
          : msg.content
          ? [{ $type: "text", text: String(msg.content) }]
          : [];
        return (
          blocks
            .filter(
              (b) => b && (b.$type === "text" || b.type === "text") && typeof b.text === "string"
            )
            .map((b) => b.text)
            .join("\n")
            .trim()
        );
      }

      function isRenderable(msg) {
        if (msg.role !== "user" && msg.role !== "assistant") return false;
        return getTextFromMessage(msg).length > 0;
      }

      function toOpenAIMsg(msg) {
        if (!msg) return msg;
        if (Array.isArray(msg.contents)) return msg;
        if (typeof msg.content === "string" && msg.content.trim().length > 0) {
          return {
            role: msg.role,
            contents: [{ $type: "text", text: msg.content }],
          };
        }
        // default empty
        return { role: msg.role, contents: [] };
      }

      function App() {
        const [messages, setMessages] = useState([]);
        const [input, setInput] = useState("");
        const [isSending, setIsSending] = useState(false);
        const [error, setError] = useState(null);
        const bottomRef = useRef(null);

        useEffect(() => {
          bottomRef.current?.scrollIntoView({ behavior: "smooth" });
        }, [messages.length]);

        const visibleMessages = useMemo(() => messages.filter(isRenderable), [messages]);

        async function sendMessage(e) {
          e?.preventDefault();
          if (!input.trim() || isSending) return;
          setError(null);

          const userMsg = {
            role: "user",
            contents: [
              {
                $type: "text",
                text: input.trim(),
              },
            ],
          };
          const nextHistory = [...messages, userMsg];
          setMessages(nextHistory);
          setInput("");
          setIsSending(true);

          try {
            const res = await fetch("http://localhost:5108/chat", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(nextHistory.map(toOpenAIMsg)),
            });
            if (!res.ok) throw new Error("HTTP " + res.status);
            // Be tolerant: backend may return
            // - an array of messages
            // - an object with { messages: [...] }
            // - a single message object
            // - plain text
            const contentType = res.headers.get("content-type") || "";
            if (contentType.includes("application/json")) {
              const data = await res.json();
              const msgs = Array.isArray(data)
                ? data
                : Array.isArray(data?.messages)
                ? data.messages
                : data && data.role
                ? [data]
                : [];
              if (msgs.length === 0) throw new Error("Bad response");
              setMessages((prev) => [...prev, ...msgs]);
            } else {
              const text = await res.text();
              if (text && text.trim().length) {
                setMessages((prev) => [
                  ...prev,
                  { role: "assistant", contents: [{ $type: "text", text }] },
                ]);
              } else {
                throw new Error("Empty response");
              }
            }
          } catch (err) {
            console.error(err);
            setError(err.message);
            setMessages((prev) => [
              ...prev,
              {
                role: "assistant",
                contents: [{ $type: "text", text: "Sorryâ€”something went wrong." }],
              },
            ]);
          } finally {
            setIsSending(false);
          }
        }

        function onKeyDown(e) {
          if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
          }
        }

        function clearChat() {
          setMessages([]);
          setError(null);
        }

        return (
          <div className="min-h-screen flex flex-col bg-neutral-100 text-neutral-900">
            <header className="sticky top-0 z-10 bg-white border-b">
              <div className="mx-auto max-w-3xl px-4 py-3 flex items-center justify-between">
                <h1 className="text-lg font-semibold">ðŸ¤– Chatbot Demo</h1>
                <button onClick={clearChat} disabled={isSending}>Clear Chat</button>
              </div>
            </header>

            <main className="flex-1">
              <div className="mx-auto max-w-3xl px-4 py-6">
                {visibleMessages.length === 0 ? (
                  <div className="text-center text-neutral-500 py-16">Start a conversation below.</div>
                ) : (
                  <ul>
                    {visibleMessages.map((m, i) => (
                      <li key={i} className="flex gap-3 mb-2">
                        <div className={clsx("w-8 h-8 flex items-center justify-center", m.role === "user" ? "bg-blue-600 text-white" : "bg-green-600 text-white")}>
                          {m.role === "user" ? "U" : "A"}
                        </div>
                        <div className="flex-1 border rounded p-2 whitespace-pre-wrap" dangerouslySetInnerHTML={{ __html: renderMessageHtml(m) }}></div>
                      </li>
                    ))}
                    <div ref={bottomRef}></div>
                  </ul>
                )}
                {error && <div style={{ color: "red" }}>Error: {error}</div>}
              </div>
            </main>

            <footer className="sticky bottom-0 bg-white border-t">
              <div className="mx-auto max-w-3xl px-4 py-4">
                <form onSubmit={sendMessage} className="flex gap-2 items-end">
                  <textarea
                    rows={3}
                    placeholder="Type a messageâ€¦"
                    value={input}
                    onChange={(e) => setInput(e.target.value)}
                    onKeyDown={onKeyDown}
                    className="flex-1 border rounded p-2"
                  />
                  <button
                    type="submit"
                    disabled={isSending || !input.trim()}
                    className="px-4 py-2 rounded bg-blue-600 text-white disabled:bg-gray-300"
                  >
                    {isSending ? "Sendingâ€¦" : "Send"}
                  </button>
                </form>
              </div>
            </footer>
          </div>
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(<App />);
    </script>
  </body>
</html>